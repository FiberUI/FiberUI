{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-user-media",
  "type": "registry:hook",
  "title": "useUserMedia",
  "description": "A hook for accessing and managing the user's camera and microphone.",
  "categories": [
    "webrtc"
  ],
  "files": [
    {
      "path": "webrtc/use-user-media.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Constraints for getUserMedia\n */\nexport interface UseUserMediaConstraints {\n    /** Audio constraints (true, false, or MediaTrackConstraints) */\n    audio?: boolean | MediaTrackConstraints;\n    /** Video constraints (true, false, or MediaTrackConstraints) */\n    video?: boolean | MediaTrackConstraints;\n}\n\n/**\n * Options for the useUserMedia hook\n */\nexport interface UseUserMediaOptions {\n    /** Initial constraints (default: { audio: true, video: true }) */\n    constraints?: UseUserMediaConstraints;\n    /** Whether to start automatically on mount (default: false) */\n    autoStart?: boolean;\n}\n\n/**\n * Return type for the useUserMedia hook\n */\nexport interface UseUserMediaReturn {\n    /** The active media stream */\n    stream: MediaStream | null;\n    /** Whether the stream is being acquired */\n    isLoading: boolean;\n    /** Whether a stream is currently active */\n    isActive: boolean;\n    /** Error if stream acquisition failed */\n    error: Error | null;\n    /** Whether the API is supported */\n    isSupported: boolean;\n    /** Start the media stream with optional constraints */\n    start: (constraints?: UseUserMediaConstraints) => Promise<boolean>;\n    /** Stop all tracks and release the stream */\n    stop: () => void;\n    /** Switch to a different audio device */\n    switchAudioDevice: (deviceId: string) => Promise<boolean>;\n    /** Switch to a different video device */\n    switchVideoDevice: (deviceId: string) => Promise<boolean>;\n    /** Get the current audio track */\n    audioTrack: MediaStreamTrack | null;\n    /** Get the current video track */\n    videoTrack: MediaStreamTrack | null;\n    /** Pause video track (stops camera hardware) */\n    pauseVideo: () => void;\n    /** Resume video track (restarts camera) */\n    resumeVideo: () => Promise<boolean>;\n    /** Whether video is currently paused */\n    isVideoPaused: boolean;\n    /** Pause audio track (stops microphone) */\n    pauseAudio: () => void;\n    /** Resume audio track (restarts microphone) */\n    resumeAudio: () => Promise<boolean>;\n    /** Whether audio is currently paused */\n    isAudioPaused: boolean;\n}\n\n/**\n * A React hook for accessing the user's camera and microphone using getUserMedia.\n * Provides controls for starting, stopping, and switching devices.\n *\n * @param options - Configuration options for the hook\n * @returns UseUserMediaReturn object with stream, states, and control functions\n *\n * @example\n * ```tsx\n * const { stream, start, stop, isActive } = useUserMedia();\n *\n * // Start with default constraints\n * await start();\n *\n * // Use stream in a video element\n * videoRef.current.srcObject = stream;\n *\n * // Stop when done\n * stop();\n * ```\n */\nexport function useUserMedia(\n    options: UseUserMediaOptions = {},\n): UseUserMediaReturn {\n    const { constraints: initialConstraints, autoStart = false } = options;\n\n    const [stream, setStream] = useState<MediaStream | null>(null);\n    const [isLoading, setIsLoading] = useState(false);\n    const [error, setError] = useState<Error | null>(null);\n    const [isVideoPaused, setIsVideoPaused] = useState(false);\n    const [isAudioPaused, setIsAudioPaused] = useState(false);\n    const streamRef = useRef<MediaStream | null>(null);\n    const requestRef = useRef<number>(0);\n    const constraintsRef = useRef<UseUserMediaConstraints>(\n        initialConstraints ?? { audio: true, video: true },\n    );\n\n    // Check if API is supported\n    const isSupported =\n        typeof navigator !== \"undefined\" &&\n        !!navigator.mediaDevices?.getUserMedia;\n\n    // Get tracks from current stream\n    const audioTrack = stream?.getAudioTracks()[0] ?? null;\n    const videoTrack = stream?.getVideoTracks()[0] ?? null;\n\n    const stopTrack = useCallback((track: MediaStreamTrack) => {\n        track.stop();\n        track.enabled = false;\n    }, []);\n\n    // Stop all tracks in a stream\n    const stopTracks = useCallback((mediaStream: MediaStream | null) => {\n        if (mediaStream) {\n            mediaStream.getTracks().forEach(stopTrack);\n        }\n    }, []);\n\n    // Stop the current stream\n    const stop = useCallback(() => {\n        stopTracks(streamRef.current);\n        streamRef.current = null;\n        setStream(null);\n        setError(null);\n    }, [stopTracks]);\n\n    // Start the media stream\n    const start = useCallback(\n        async (newConstraints?: UseUserMediaConstraints): Promise<boolean> => {\n            if (!isSupported) {\n                setError(new Error(\"getUserMedia is not supported\"));\n                return false;\n            }\n\n            // Update constraints if provided\n            if (newConstraints) {\n                constraintsRef.current = newConstraints;\n            }\n\n            // Increment request ID\n            const requestId = requestRef.current + 1;\n            requestRef.current = requestId;\n\n            setIsLoading(true);\n            setError(null);\n\n            try {\n                // Stop existing stream first\n                stopTracks(streamRef.current);\n\n                const mediaStream = await navigator.mediaDevices.getUserMedia(\n                    constraintsRef.current,\n                );\n\n                // Check if this is still the latest request\n                if (requestRef.current !== requestId) {\n                    // This request is stale, stop the stream we just got\n                    stopTracks(mediaStream);\n                    return false;\n                }\n\n                streamRef.current = mediaStream;\n                setStream(mediaStream);\n                setIsLoading(false);\n                return true;\n            } catch (err) {\n                // Only handle error if we are still the active request\n                if (requestRef.current === requestId) {\n                    const error =\n                        err instanceof Error\n                            ? err\n                            : new Error(\"Failed to access media devices\");\n                    setError(error);\n                    setStream(null);\n                    setIsLoading(false);\n                }\n                return false;\n            }\n        },\n        [isSupported, stopTracks],\n    );\n\n    // Switch audio device\n    const switchAudioDevice = useCallback(\n        async (deviceId: string): Promise<boolean> => {\n            const currentVideo = constraintsRef.current.video;\n            const newConstraints: UseUserMediaConstraints = {\n                audio: { deviceId: { exact: deviceId } },\n                video: currentVideo,\n            };\n            return start(newConstraints);\n        },\n        [start],\n    );\n\n    // Switch video device\n    const switchVideoDevice = useCallback(\n        async (deviceId: string): Promise<boolean> => {\n            const currentAudio = constraintsRef.current.audio;\n            const newConstraints: UseUserMediaConstraints = {\n                audio: currentAudio,\n                video: { deviceId: { exact: deviceId } },\n            };\n            return start(newConstraints);\n        },\n        [start],\n    );\n\n    // Pause video (stops camera hardware - light turns off)\n    const pauseVideo = useCallback(() => {\n        if (!streamRef.current) return;\n\n        const videoTracks = streamRef.current.getVideoTracks();\n        videoTracks.forEach((track) => {\n            track.stop();\n            streamRef.current?.removeTrack(track);\n        });\n        setIsVideoPaused(true);\n        // Trigger re-render with updated stream\n        setStream(streamRef.current);\n    }, []);\n\n    // Resume video (restarts camera)\n    const resumeVideo = useCallback(async (): Promise<boolean> => {\n        if (!streamRef.current || !isSupported) return false;\n\n        try {\n            const videoConstraints = constraintsRef.current.video;\n            if (!videoConstraints) return false;\n\n            const newStream = await navigator.mediaDevices.getUserMedia({\n                video: videoConstraints,\n                audio: false,\n            });\n\n            const newVideoTrack = newStream.getVideoTracks()[0];\n            if (newVideoTrack && streamRef.current) {\n                streamRef.current.addTrack(newVideoTrack);\n                setIsVideoPaused(false);\n                // Trigger re-render with updated stream\n                setStream(streamRef.current);\n                return true;\n            }\n            return false;\n        } catch (err) {\n            console.error(\"Failed to resume video:\", err);\n            return false;\n        }\n    }, [isSupported]);\n\n    // Pause audio (stops microphone)\n    const pauseAudio = useCallback(() => {\n        if (!streamRef.current) return;\n\n        const audioTracks = streamRef.current.getAudioTracks();\n        audioTracks.forEach((track) => {\n            track.stop();\n            streamRef.current?.removeTrack(track);\n        });\n        setIsAudioPaused(true);\n        setStream(streamRef.current);\n    }, []);\n\n    // Resume audio (restarts microphone)\n    const resumeAudio = useCallback(async (): Promise<boolean> => {\n        if (!streamRef.current || !isSupported) return false;\n\n        try {\n            const audioConstraints = constraintsRef.current.audio;\n            if (!audioConstraints) return false;\n\n            const newStream = await navigator.mediaDevices.getUserMedia({\n                audio: audioConstraints,\n                video: false,\n            });\n\n            const newAudioTrack = newStream.getAudioTracks()[0];\n            if (newAudioTrack && streamRef.current) {\n                streamRef.current.addTrack(newAudioTrack);\n                setIsAudioPaused(false);\n                setStream(streamRef.current);\n                return true;\n            }\n            return false;\n        } catch (err) {\n            console.error(\"Failed to resume audio:\", err);\n            return false;\n        }\n    }, [isSupported]);\n\n    // Auto-start on mount if enabled\n    useEffect(() => {\n        if (autoStart && isSupported) {\n            start();\n        }\n    }, [autoStart, isSupported]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (streamRef.current) {\n                streamRef.current.getTracks().forEach(stopTrack);\n            }\n        };\n    }, []);\n\n    return {\n        stream,\n        isLoading,\n        isActive: stream !== null,\n        error,\n        isSupported,\n        start,\n        stop,\n        switchAudioDevice,\n        switchVideoDevice,\n        audioTrack,\n        videoTrack,\n        pauseVideo,\n        resumeVideo,\n        isVideoPaused,\n        pauseAudio,\n        resumeAudio,\n        isAudioPaused,\n    };\n}\n\nexport default useUserMedia;\n"
    }
  ]
}