{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-speech-synthesis",
  "type": "registry:hook",
  "title": "useSpeechSynthesis",
  "description": "A React hook for text-to-speech synthesis using the Web Speech API.",
  "categories": [
    "speech"
  ],
  "files": [
    {
      "path": "speech/use-speech-synthesis.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Options for the useSpeechSynthesis hook\n */\nexport interface UseSpeechSynthesisOptions {\n    /** The voice to use for speech (default: system default) */\n    voice?: SpeechSynthesisVoice | null;\n    /** Speech rate from 0.1 to 10 (default: 1) */\n    rate?: number;\n    /** Speech pitch from 0 to 2 (default: 1) */\n    pitch?: number;\n    /** Speech volume from 0 to 1 (default: 1) */\n    volume?: number;\n    /** Callback when speech starts */\n    onStart?: () => void;\n    /** Callback when speech ends */\n    onEnd?: () => void;\n    /** Callback when an error occurs */\n    onError?: (error: SpeechSynthesisErrorEvent) => void;\n    /** Callback when a word boundary is reached (for highlighting) */\n    onBoundary?: (event: SpeechSynthesisEvent) => void;\n}\n\n/**\n * Return type for useSpeechSynthesis hook\n */\nexport interface UseSpeechSynthesisReturn {\n    /** Speak the given text */\n    speak: (text: string) => void;\n    /** Cancel all speech */\n    cancel: () => void;\n    /** Pause speech */\n    pause: () => void;\n    /** Resume paused speech */\n    resume: () => void;\n    /** Whether speech is currently playing */\n    isSpeaking: boolean;\n    /** Whether speech is paused */\n    isPaused: boolean;\n    /** Whether the Speech Synthesis API is supported */\n    isSupported: boolean;\n    /** Available voices */\n    voices: SpeechSynthesisVoice[];\n    /** Current character index being spoken (for highlighting) */\n    currentCharIndex: number;\n    /** Error event if speech failed */\n    error: SpeechSynthesisErrorEvent | null;\n    /** Human-readable error message */\n    errorMessage: string | null;\n}\n\n/**\n * Human-readable error messages for speech synthesis errors\n */\nfunction getErrorMessage(error: SpeechSynthesisErrorEvent): string {\n    switch (error.error) {\n        case \"canceled\":\n            return \"Speech was canceled.\";\n        case \"interrupted\":\n            return \"Speech was interrupted.\";\n        case \"audio-busy\":\n            return \"Audio output is busy.\";\n        case \"audio-hardware\":\n            return \"Audio hardware error occurred.\";\n        case \"network\":\n            return \"Network error during speech synthesis.\";\n        case \"synthesis-unavailable\":\n            return \"Speech synthesis is not available.\";\n        case \"synthesis-failed\":\n            return \"Speech synthesis failed.\";\n        case \"language-unavailable\":\n            return \"The specified language is not available.\";\n        case \"voice-unavailable\":\n            return \"The specified voice is not available.\";\n        case \"text-too-long\":\n            return \"The text is too long to synthesize.\";\n        case \"invalid-argument\":\n            return \"Invalid argument provided.\";\n        case \"not-allowed\":\n            return \"Speech synthesis is not allowed.\";\n        default:\n            return \"An unknown error occurred during speech synthesis.\";\n    }\n}\n\n/**\n * A React hook that provides text-to-speech functionality using the\n * Web Speech Synthesis API.\n *\n * @param options - Configuration options for the hook\n * @returns UseSpeechSynthesisReturn object with speak function and state\n *\n * @example\n * ```tsx\n * // Basic usage\n * const { speak, cancel, isSpeaking, voices } = useSpeechSynthesis();\n *\n * // With options\n * const { speak, voices } = useSpeechSynthesis({\n *     voice: voices.find(v => v.lang === 'en-GB'),\n *     rate: 1.2,\n *     pitch: 1.1\n * });\n *\n * // Speak text\n * speak(\"Hello, world!\");\n * ```\n */\nexport function useSpeechSynthesis(\n    options: UseSpeechSynthesisOptions = {},\n): UseSpeechSynthesisReturn {\n    const {\n        voice = null,\n        rate = 1,\n        pitch = 1,\n        volume = 1,\n        onStart,\n        onEnd,\n        onError,\n        onBoundary,\n    } = options;\n\n    const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);\n    const [isSpeaking, setIsSpeaking] = useState(false);\n    const [isPaused, setIsPaused] = useState(false);\n    const [currentCharIndex, setCurrentCharIndex] = useState(0);\n    const [error, setError] = useState<SpeechSynthesisErrorEvent | null>(null);\n    const [errorMessage, setErrorMessage] = useState<string | null>(null);\n\n    const utteranceRef = useRef<SpeechSynthesisUtterance | null>(null);\n\n    // Check if API is supported\n    const isSupported =\n        typeof window !== \"undefined\" && \"speechSynthesis\" in window;\n\n    // Load available voices\n    useEffect(() => {\n        if (!isSupported) return;\n\n        const loadVoices = () => {\n            const availableVoices = window.speechSynthesis.getVoices();\n            setVoices(availableVoices);\n        };\n\n        // Voices may load asynchronously\n        loadVoices();\n\n        // Chrome requires this event listener\n        if (window.speechSynthesis.onvoiceschanged !== undefined) {\n            window.speechSynthesis.onvoiceschanged = loadVoices;\n        }\n\n        return () => {\n            if (window.speechSynthesis.onvoiceschanged !== undefined) {\n                window.speechSynthesis.onvoiceschanged = null;\n            }\n        };\n    }, [isSupported]);\n\n    // Sync speaking state with the API\n    useEffect(() => {\n        if (!isSupported) return;\n\n        const checkSpeakingState = () => {\n            setIsSpeaking(window.speechSynthesis.speaking);\n            setIsPaused(window.speechSynthesis.paused);\n        };\n\n        // Poll for state changes (some browsers don't fire events reliably)\n        const interval = setInterval(checkSpeakingState, 100);\n\n        return () => clearInterval(interval);\n    }, [isSupported]);\n\n    const speak = useCallback(\n        (text: string) => {\n            if (!isSupported) return;\n\n            // Cancel any ongoing speech\n            window.speechSynthesis.cancel();\n\n            const utterance = new SpeechSynthesisUtterance(text);\n\n            // Apply options\n            if (voice) utterance.voice = voice;\n            utterance.rate = Math.max(0.1, Math.min(10, rate));\n            utterance.pitch = Math.max(0, Math.min(2, pitch));\n            utterance.volume = Math.max(0, Math.min(1, volume));\n\n            // Event handlers\n            utterance.onstart = () => {\n                setIsSpeaking(true);\n                setIsPaused(false);\n                setError(null);\n                setErrorMessage(null);\n                setCurrentCharIndex(0);\n                onStart?.();\n            };\n\n            utterance.onend = () => {\n                setIsSpeaking(false);\n                setIsPaused(false);\n                setCurrentCharIndex(0);\n                onEnd?.();\n            };\n\n            utterance.onerror = (event) => {\n                // Ignore 'interrupted' and 'canceled' as they're not real errors\n                if (\n                    event.error === \"interrupted\" ||\n                    event.error === \"canceled\"\n                ) {\n                    setIsSpeaking(false);\n                    setIsPaused(false);\n                    return;\n                }\n\n                setError(event);\n                setErrorMessage(getErrorMessage(event));\n                setIsSpeaking(false);\n                setIsPaused(false);\n                onError?.(event);\n            };\n\n            utterance.onboundary = (event) => {\n                setCurrentCharIndex(event.charIndex);\n                onBoundary?.(event);\n            };\n\n            utteranceRef.current = utterance;\n\n            // Chrome has a bug where long texts stop after ~15 seconds\n            // Workaround: pause and resume periodically\n            window.speechSynthesis.speak(utterance);\n        },\n        [\n            isSupported,\n            voice,\n            rate,\n            pitch,\n            volume,\n            onStart,\n            onEnd,\n            onError,\n            onBoundary,\n        ],\n    );\n\n    const cancel = useCallback(() => {\n        if (!isSupported) return;\n        window.speechSynthesis.cancel();\n        setIsSpeaking(false);\n        setIsPaused(false);\n        setCurrentCharIndex(0);\n    }, [isSupported]);\n\n    const pause = useCallback(() => {\n        if (!isSupported) return;\n        window.speechSynthesis.pause();\n        setIsPaused(true);\n    }, [isSupported]);\n\n    const resume = useCallback(() => {\n        if (!isSupported) return;\n        window.speechSynthesis.resume();\n        setIsPaused(false);\n    }, [isSupported]);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (isSupported) {\n                window.speechSynthesis.cancel();\n            }\n        };\n    }, [isSupported]);\n\n    return {\n        speak,\n        cancel,\n        pause,\n        resume,\n        isSpeaking,\n        isPaused,\n        isSupported,\n        voices,\n        currentCharIndex,\n        error,\n        errorMessage,\n    };\n}\n\nexport default useSpeechSynthesis;\n"
    }
  ]
}