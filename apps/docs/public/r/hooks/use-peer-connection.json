{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-peer-connection",
  "type": "registry:hook",
  "title": "usePeerConnection",
  "description": "The core WebRTC hook for managing peer connections.",
  "categories": [
    "webrtc"
  ],
  "files": [
    {
      "path": "webrtc/use-peer-connection.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * ICE server configuration\n */\nexport interface IceServer {\n    urls: string | string[];\n    username?: string;\n    credential?: string;\n}\n\n/**\n * Options for the usePeerConnection hook\n */\nexport interface UsePeerConnectionOptions {\n    /** ICE servers for STUN/TURN */\n    iceServers?: IceServer[];\n    /** ICE transport policy: \"all\" or \"relay\" */\n    iceTransportPolicy?: RTCIceTransportPolicy;\n    /** Bundle policy for media */\n    bundlePolicy?: RTCBundlePolicy;\n    /** Callback when remote track is received */\n    onTrack?: (event: RTCTrackEvent) => void;\n    /** Callback when ICE candidate is generated */\n    onIceCandidate?: (candidate: RTCIceCandidate | null) => void;\n    /** Callback when connection state changes */\n    onConnectionStateChange?: (state: RTCPeerConnectionState) => void;\n    /** Callback when data channel is received */\n    onDataChannel?: (channel: RTCDataChannel) => void;\n}\n\n/**\n * Return type for the usePeerConnection hook\n */\nexport interface UsePeerConnectionReturn {\n    /** The RTCPeerConnection instance */\n    peerConnection: RTCPeerConnection | null;\n    /** Current connection state */\n    connectionState: RTCPeerConnectionState;\n    /** Current ICE connection state */\n    iceConnectionState: RTCIceConnectionState;\n    /** Current ICE gathering state */\n    iceGatheringState: RTCIceGatheringState;\n    /** Current signaling state */\n    signalingState: RTCSignalingState;\n    /** Local session description */\n    localDescription: RTCSessionDescription | null;\n    /** Remote session description */\n    remoteDescription: RTCSessionDescription | null;\n    /** Remote streams received */\n    remoteStreams: MediaStream[];\n    /** Whether the API is supported */\n    isSupported: boolean;\n    /** Create an SDP offer */\n    createOffer: (\n        options?: RTCOfferOptions,\n    ) => Promise<RTCSessionDescriptionInit | null>;\n    /** Create an SDP answer */\n    createAnswer: (\n        options?: RTCAnswerOptions,\n    ) => Promise<RTCSessionDescriptionInit | null>;\n    /** Set the local description */\n    setLocalDescription: (desc: RTCSessionDescriptionInit) => Promise<boolean>;\n    /** Set the remote description */\n    setRemoteDescription: (desc: RTCSessionDescriptionInit) => Promise<boolean>;\n    /** Add an ICE candidate */\n    addIceCandidate: (candidate: RTCIceCandidateInit) => Promise<boolean>;\n    /** Add a track to the connection */\n    addTrack: (\n        track: MediaStreamTrack,\n        ...streams: MediaStream[]\n    ) => RTCRtpSender | null;\n    /** Remove a track sender */\n    removeTrack: (sender: RTCRtpSender) => void;\n    /** Create a data channel */\n    createDataChannel: (\n        label: string,\n        options?: RTCDataChannelInit,\n    ) => RTCDataChannel | null;\n    /** Close the connection */\n    close: () => void;\n    /** Restart ICE */\n    restartIce: () => void;\n}\n\nconst DEFAULT_ICE_SERVERS: IceServer[] = [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    { urls: \"stun:stun1.l.google.com:19302\" },\n];\n\n/**\n * A React hook for managing RTCPeerConnection lifecycle.\n * Handles SDP negotiation, ICE candidates, and media tracks.\n *\n * @param options - Configuration options for the peer connection\n * @returns UsePeerConnectionReturn object with connection, states, and methods\n *\n * @example\n * ```tsx\n * const {\n *     peerConnection,\n *     connectionState,\n *     createOffer,\n *     setRemoteDescription,\n *     addIceCandidate,\n *     addTrack,\n * } = usePeerConnection({\n *     onIceCandidate: (candidate) => sendToRemote(candidate),\n *     onTrack: (event) => setRemoteStream(event.streams[0]),\n * });\n *\n * // Create and send offer\n * const offer = await createOffer();\n * sendToRemote({ type: \"offer\", sdp: offer });\n * ```\n */\nexport function usePeerConnection(\n    options: UsePeerConnectionOptions = {},\n): UsePeerConnectionReturn {\n    const {\n        iceServers = DEFAULT_ICE_SERVERS,\n        iceTransportPolicy = \"all\",\n        bundlePolicy = \"balanced\",\n        onTrack,\n        onIceCandidate,\n        onConnectionStateChange,\n        onDataChannel,\n    } = options;\n\n    const [peerConnection, setPeerConnection] =\n        useState<RTCPeerConnection | null>(null);\n    const [connectionState, setConnectionState] =\n        useState<RTCPeerConnectionState>(\"new\");\n    const [iceConnectionState, setIceConnectionState] =\n        useState<RTCIceConnectionState>(\"new\");\n    const [iceGatheringState, setIceGatheringState] =\n        useState<RTCIceGatheringState>(\"new\");\n    const [signalingState, setSignalingState] =\n        useState<RTCSignalingState>(\"stable\");\n    const [remoteStreams, setRemoteStreams] = useState<MediaStream[]>([]);\n\n    // Store callbacks in refs to avoid dependency issues\n    const onTrackRef = useRef(onTrack);\n    const onIceCandidateRef = useRef(onIceCandidate);\n    const onConnectionStateChangeRef = useRef(onConnectionStateChange);\n    const onDataChannelRef = useRef(onDataChannel);\n\n    onTrackRef.current = onTrack;\n    onIceCandidateRef.current = onIceCandidate;\n    onConnectionStateChangeRef.current = onConnectionStateChange;\n    onDataChannelRef.current = onDataChannel;\n\n    // Check if API is supported\n    const isSupported =\n        typeof window !== \"undefined\" && \"RTCPeerConnection\" in window;\n\n    // Initialize peer connection\n    useEffect(() => {\n        if (!isSupported) return;\n\n        const pc = new RTCPeerConnection({\n            iceServers,\n            iceTransportPolicy,\n            bundlePolicy,\n        });\n\n        // Event handlers\n        pc.onconnectionstatechange = () => {\n            setConnectionState(pc.connectionState);\n            onConnectionStateChangeRef.current?.(pc.connectionState);\n        };\n\n        pc.oniceconnectionstatechange = () => {\n            setIceConnectionState(pc.iceConnectionState);\n        };\n\n        pc.onicegatheringstatechange = () => {\n            setIceGatheringState(pc.iceGatheringState);\n        };\n\n        pc.onsignalingstatechange = () => {\n            setSignalingState(pc.signalingState);\n        };\n\n        pc.onicecandidate = (event) => {\n            onIceCandidateRef.current?.(event.candidate);\n        };\n\n        pc.ontrack = (event) => {\n            onTrackRef.current?.(event);\n            setRemoteStreams((prev) => {\n                const newStreams = event.streams.filter(\n                    (s) => !prev.some((p) => p.id === s.id),\n                );\n                return [...prev, ...newStreams];\n            });\n        };\n\n        pc.ondatachannel = (event) => {\n            onDataChannelRef.current?.(event.channel);\n        };\n\n        setPeerConnection(pc);\n\n        return () => {\n            pc.close();\n        };\n    }, [isSupported, iceTransportPolicy, bundlePolicy]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    // Create offer\n    const createOffer = useCallback(\n        async (\n            offerOptions?: RTCOfferOptions,\n        ): Promise<RTCSessionDescriptionInit | null> => {\n            if (!peerConnection || peerConnection.signalingState === \"closed\")\n                return null;\n\n            try {\n                const offer = await peerConnection.createOffer(offerOptions);\n                await peerConnection.setLocalDescription(offer);\n                return offer;\n            } catch (err) {\n                console.error(\"Failed to create offer:\", err);\n                return null;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Create answer\n    const createAnswer = useCallback(\n        async (\n            answerOptions?: RTCAnswerOptions,\n        ): Promise<RTCSessionDescriptionInit | null> => {\n            if (!peerConnection || peerConnection.signalingState === \"closed\")\n                return null;\n\n            try {\n                const answer = await peerConnection.createAnswer(answerOptions);\n                await peerConnection.setLocalDescription(answer);\n                return answer;\n            } catch (err) {\n                console.error(\"Failed to create answer:\", err);\n                return null;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Set local description\n    const setLocalDescription = useCallback(\n        async (desc: RTCSessionDescriptionInit): Promise<boolean> => {\n            if (!peerConnection || peerConnection.signalingState === \"closed\")\n                return false;\n\n            try {\n                await peerConnection.setLocalDescription(desc);\n                return true;\n            } catch (err) {\n                console.error(\"Failed to set local description:\", err);\n                return false;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Set remote description\n    const setRemoteDescription = useCallback(\n        async (desc: RTCSessionDescriptionInit): Promise<boolean> => {\n            if (!peerConnection || peerConnection.signalingState === \"closed\")\n                return false;\n\n            try {\n                await peerConnection.setRemoteDescription(\n                    new RTCSessionDescription(desc),\n                );\n                return true;\n            } catch (err) {\n                console.error(\"Failed to set remote description:\", err);\n                return false;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Add ICE candidate\n    const addIceCandidate = useCallback(\n        async (candidate: RTCIceCandidateInit): Promise<boolean> => {\n            if (!peerConnection || peerConnection.signalingState === \"closed\")\n                return false;\n\n            try {\n                await peerConnection.addIceCandidate(\n                    new RTCIceCandidate(candidate),\n                );\n                return true;\n            } catch (err) {\n                console.error(\"Failed to add ICE candidate:\", err);\n                return false;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Add track\n    const addTrack = useCallback(\n        (\n            track: MediaStreamTrack,\n            ...streams: MediaStream[]\n        ): RTCRtpSender | null => {\n            if (!peerConnection) return null;\n\n            // Check if track already exists\n            const senders = peerConnection.getSenders();\n            const existingSender = senders.find((s) => s.track === track);\n            if (existingSender) {\n                return existingSender;\n            }\n\n            try {\n                return peerConnection.addTrack(track, ...streams);\n            } catch (err) {\n                console.error(\"Failed to add track:\", err);\n                return null;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Remove track\n    const removeTrack = useCallback(\n        (sender: RTCRtpSender): void => {\n            if (!peerConnection) return;\n\n            try {\n                peerConnection.removeTrack(sender);\n            } catch (err) {\n                console.error(\"Failed to remove track:\", err);\n            }\n        },\n        [peerConnection],\n    );\n\n    // Create data channel\n    const createDataChannel = useCallback(\n        (\n            label: string,\n            channelOptions?: RTCDataChannelInit,\n        ): RTCDataChannel | null => {\n            if (!peerConnection) return null;\n\n            try {\n                return peerConnection.createDataChannel(label, channelOptions);\n            } catch (err) {\n                console.error(\"Failed to create data channel:\", err);\n                return null;\n            }\n        },\n        [peerConnection],\n    );\n\n    // Close connection\n    const close = useCallback(() => {\n        if (peerConnection) {\n            peerConnection.close();\n        }\n        setRemoteStreams([]);\n    }, [peerConnection]);\n\n    // Restart ICE\n    const restartIce = useCallback(() => {\n        if (peerConnection) {\n            peerConnection.restartIce();\n        }\n    }, [peerConnection]);\n\n    return {\n        peerConnection,\n        connectionState,\n        iceConnectionState,\n        iceGatheringState,\n        signalingState,\n        localDescription: peerConnection?.localDescription ?? null,\n        remoteDescription: peerConnection?.remoteDescription ?? null,\n        remoteStreams,\n        isSupported,\n        createOffer,\n        createAnswer,\n        setLocalDescription,\n        setRemoteDescription,\n        addIceCandidate,\n        addTrack,\n        removeTrack,\n        createDataChannel,\n        close,\n        restartIce,\n    };\n}\n\nexport default usePeerConnection;\n"
    }
  ]
}