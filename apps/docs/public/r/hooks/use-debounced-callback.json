{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-debounced-callback",
  "type": "registry:hook",
  "title": "useDebouncedCallback",
  "description": "A hook for debouncing callback functions.",
  "categories": [
    "utility"
  ],
  "dependencies": [
    "lodash"
  ],
  "files": [
    {
      "path": "utility/use-debounced-callback.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Options for the useDebouncedCallback hook\n */\nexport interface UseDebouncedCallbackOptions {\n    /** Delay in milliseconds before the callback executes (default: 500) */\n    delay?: number;\n    /** If true, execute immediately on the first call, then debounce subsequent calls */\n    leading?: boolean;\n}\n\n/**\n * Return type for useDebouncedCallback hook\n */\nexport interface UseDebouncedCallbackReturn<T extends (...args: any[]) => any> {\n    /** The debounced function */\n    debouncedFn: (...args: Parameters<T>) => void;\n    /** Whether a call is pending */\n    isPending: boolean;\n    /** Cancel the pending call */\n    cancel: () => void;\n    /** Immediately execute with the last arguments */\n    flush: () => void;\n}\n\n/**\n * A React hook that returns a debounced version of a callback function.\n * The callback will only be invoked after the specified delay has passed\n * without being called again.\n *\n * @param callback - The function to debounce\n * @param options - Configuration options\n * @returns UseDebouncedCallbackReturn object with debounced function and controls\n *\n * @example\n * ```tsx\n * const { debouncedFn: handleSearch } = useDebouncedCallback(\n *     (query: string) => {\n *         console.log(\"Searching for:\", query);\n *         fetchResults(query);\n *     },\n *     { delay: 300 }\n * );\n *\n * <input onChange={(e) => handleSearch(e.target.value)} />\n * ```\n */\nexport function useDebouncedCallback<T extends (...args: any[]) => any>(\n    callback: T,\n    options: UseDebouncedCallbackOptions = {},\n): UseDebouncedCallbackReturn<T> {\n    const { delay = 500, leading = false } = options;\n\n    const [isPending, setIsPending] = useState(false);\n    const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const callbackRef = useRef<T>(callback);\n    const lastArgsRef = useRef<Parameters<T> | null>(null);\n    const isFirstCall = useRef(true);\n\n    // Keep callback ref updated\n    callbackRef.current = callback;\n\n    // Cancel pending timeout\n    const cancel = useCallback(() => {\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n        }\n        setIsPending(false);\n        lastArgsRef.current = null;\n    }, []);\n\n    // Flush and execute immediately\n    const flush = useCallback(() => {\n        if (timeoutRef.current && lastArgsRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n            callbackRef.current(...lastArgsRef.current);\n            lastArgsRef.current = null;\n        }\n        setIsPending(false);\n    }, []);\n\n    // The debounced function\n    const debouncedFn = useCallback(\n        (...args: Parameters<T>) => {\n            lastArgsRef.current = args;\n\n            // Handle leading edge\n            if (leading && isFirstCall.current) {\n                isFirstCall.current = false;\n                callbackRef.current(...args);\n                return;\n            }\n\n            isFirstCall.current = false;\n            setIsPending(true);\n\n            // Clear previous timeout\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n\n            // Set new timeout\n            timeoutRef.current = setTimeout(() => {\n                callbackRef.current(...args);\n                setIsPending(false);\n                timeoutRef.current = null;\n                lastArgsRef.current = null;\n            }, delay);\n        },\n        [delay, leading],\n    );\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n        };\n    }, []);\n\n    return {\n        debouncedFn,\n        isPending,\n        cancel,\n        flush,\n    };\n}\n\nexport default useDebouncedCallback;\n"
    }
  ]
}