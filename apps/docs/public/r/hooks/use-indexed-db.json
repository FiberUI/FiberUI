{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-indexed-db",
  "type": "registry:hook",
  "title": "useIndexedDB",
  "description": "A simplified hook for managing IndexedDB with async support.",
  "categories": [
    "storage"
  ],
  "files": [
    {
      "path": "storage/use-indexed-db.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback } from \"react\";\n\n/**\n * IndexedDB hook state\n */\nexport interface UseIndexedDBState<T> {\n    /** Data retrieved from the store */\n    data: T[];\n    /** Whether the database is loading */\n    isLoading: boolean;\n    /** Error message if any */\n    error: string | null;\n    /** Whether IndexedDB is supported */\n    isSupported: boolean;\n}\n\n/**\n * IndexedDB hook return type\n */\nexport interface UseIndexedDBReturn<T> extends UseIndexedDBState<T> {\n    /** Add an item to the store */\n    add: (item: T) => Promise<IDBValidKey | null>;\n    /** Update an item in the store */\n    update: (item: T) => Promise<IDBValidKey | null>;\n    /** Delete an item by key */\n    remove: (key: IDBValidKey) => Promise<boolean>;\n    /** Get a single item by key */\n    getByKey: (key: IDBValidKey) => Promise<T | null>;\n    /** Clear all items from the store */\n    clear: () => Promise<boolean>;\n    /** Refresh data from the store */\n    refresh: () => Promise<void>;\n}\n\n/**\n * IndexedDB configuration options\n */\nexport interface UseIndexedDBOptions {\n    /** Name of the database */\n    dbName: string;\n    /** Name of the object store */\n    storeName: string;\n    /** Database version (increment to trigger upgrade) */\n    version?: number;\n    /** Key path for the object store */\n    keyPath?: string;\n}\n\n/**\n * Opens an IndexedDB database\n */\nfunction openDatabase(\n    dbName: string,\n    storeName: string,\n    version: number,\n    keyPath: string,\n): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, version);\n\n        request.onerror = () => {\n            reject(\n                new Error(`Failed to open database: ${request.error?.message}`),\n            );\n        };\n\n        request.onsuccess = () => {\n            resolve(request.result);\n        };\n\n        request.onupgradeneeded = (event) => {\n            const db = (event.target as IDBOpenDBRequest).result;\n            if (!db.objectStoreNames.contains(storeName)) {\n                db.createObjectStore(storeName, {\n                    keyPath,\n                    autoIncrement: !keyPath,\n                });\n            }\n        };\n    });\n}\n\n/**\n * A React hook for interacting with IndexedDB.\n * Provides CRUD operations for storing large amounts of structured data.\n *\n * @param options - Configuration options for the database\n * @returns State and methods for interacting with IndexedDB\n *\n * @example\n * ```tsx\n * interface Todo {\n *     id: string;\n *     text: string;\n *     completed: boolean;\n * }\n *\n * const { data, add, remove, isLoading } = useIndexedDB<Todo>({\n *     dbName: \"myApp\",\n *     storeName: \"todos\",\n *     keyPath: \"id\",\n * });\n * ```\n */\nexport function useIndexedDB<T>(\n    options: UseIndexedDBOptions,\n): UseIndexedDBReturn<T> {\n    const { dbName, storeName, version = 1, keyPath = \"id\" } = options;\n\n    const [state, setState] = useState<UseIndexedDBState<T>>({\n        data: [],\n        isLoading: true,\n        error: null,\n        isSupported: true,\n    });\n\n    const [db, setDb] = useState<IDBDatabase | null>(null);\n\n    // Initialize database\n    useEffect(() => {\n        if (typeof window === \"undefined\" || !(\"indexedDB\" in window)) {\n            setState((s) => ({\n                ...s,\n                isSupported: false,\n                isLoading: false,\n                error: \"IndexedDB is not supported\",\n            }));\n            return;\n        }\n\n        let mounted = true;\n\n        (async () => {\n            try {\n                const database = await openDatabase(\n                    dbName,\n                    storeName,\n                    version,\n                    keyPath,\n                );\n                if (mounted) {\n                    setDb(database);\n                }\n            } catch (error) {\n                if (mounted) {\n                    setState((s) => ({\n                        ...s,\n                        isLoading: false,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : \"Failed to open database\",\n                    }));\n                }\n            }\n        })();\n\n        return () => {\n            mounted = false;\n        };\n    }, [dbName, storeName, version, keyPath]);\n\n    // Fetch all data when database is ready\n    const refresh = useCallback(async () => {\n        if (!db) return;\n\n        setState((s) => ({ ...s, isLoading: true }));\n\n        try {\n            const transaction = db.transaction(storeName, \"readonly\");\n            const store = transaction.objectStore(storeName);\n            const request = store.getAll();\n\n            request.onsuccess = () => {\n                setState((s) => ({\n                    ...s,\n                    data: request.result,\n                    isLoading: false,\n                    error: null,\n                }));\n            };\n\n            request.onerror = () => {\n                setState((s) => ({\n                    ...s,\n                    isLoading: false,\n                    error: request.error?.message ?? \"Failed to fetch data\",\n                }));\n            };\n        } catch (error) {\n            setState((s) => ({\n                ...s,\n                isLoading: false,\n                error:\n                    error instanceof Error\n                        ? error.message\n                        : \"Failed to fetch data\",\n            }));\n        }\n    }, [db, storeName]);\n\n    // Load initial data when db is ready\n    useEffect(() => {\n        if (db) {\n            refresh();\n        }\n    }, [db, refresh]);\n\n    // Add item\n    const add = useCallback(\n        async (item: T): Promise<IDBValidKey | null> => {\n            if (!db) return null;\n\n            return new Promise((resolve) => {\n                try {\n                    const transaction = db.transaction(storeName, \"readwrite\");\n                    const store = transaction.objectStore(storeName);\n                    const request = store.add(item);\n\n                    request.onsuccess = () => {\n                        refresh();\n                        resolve(request.result);\n                    };\n\n                    request.onerror = () => {\n                        setState((s) => ({\n                            ...s,\n                            error:\n                                request.error?.message ?? \"Failed to add item\",\n                        }));\n                        resolve(null);\n                    };\n                } catch (error) {\n                    setState((s) => ({\n                        ...s,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : \"Failed to add item\",\n                    }));\n                    resolve(null);\n                }\n            });\n        },\n        [db, storeName, refresh],\n    );\n\n    // Update item\n    const update = useCallback(\n        async (item: T): Promise<IDBValidKey | null> => {\n            if (!db) return null;\n\n            return new Promise((resolve) => {\n                try {\n                    const transaction = db.transaction(storeName, \"readwrite\");\n                    const store = transaction.objectStore(storeName);\n                    const request = store.put(item);\n\n                    request.onsuccess = () => {\n                        refresh();\n                        resolve(request.result);\n                    };\n\n                    request.onerror = () => {\n                        setState((s) => ({\n                            ...s,\n                            error:\n                                request.error?.message ??\n                                \"Failed to update item\",\n                        }));\n                        resolve(null);\n                    };\n                } catch (error) {\n                    setState((s) => ({\n                        ...s,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : \"Failed to update item\",\n                    }));\n                    resolve(null);\n                }\n            });\n        },\n        [db, storeName, refresh],\n    );\n\n    // Remove item\n    const remove = useCallback(\n        async (key: IDBValidKey): Promise<boolean> => {\n            if (!db) return false;\n\n            return new Promise((resolve) => {\n                try {\n                    const transaction = db.transaction(storeName, \"readwrite\");\n                    const store = transaction.objectStore(storeName);\n                    const request = store.delete(key);\n\n                    request.onsuccess = () => {\n                        refresh();\n                        resolve(true);\n                    };\n\n                    request.onerror = () => {\n                        setState((s) => ({\n                            ...s,\n                            error:\n                                request.error?.message ??\n                                \"Failed to delete item\",\n                        }));\n                        resolve(false);\n                    };\n                } catch (error) {\n                    setState((s) => ({\n                        ...s,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : \"Failed to delete item\",\n                    }));\n                    resolve(false);\n                }\n            });\n        },\n        [db, storeName, refresh],\n    );\n\n    // Get by key\n    const getByKey = useCallback(\n        async (key: IDBValidKey): Promise<T | null> => {\n            if (!db) return null;\n\n            return new Promise((resolve) => {\n                try {\n                    const transaction = db.transaction(storeName, \"readonly\");\n                    const store = transaction.objectStore(storeName);\n                    const request = store.get(key);\n\n                    request.onsuccess = () => {\n                        resolve(request.result ?? null);\n                    };\n\n                    request.onerror = () => {\n                        setState((s) => ({\n                            ...s,\n                            error:\n                                request.error?.message ?? \"Failed to get item\",\n                        }));\n                        resolve(null);\n                    };\n                } catch (error) {\n                    setState((s) => ({\n                        ...s,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : \"Failed to get item\",\n                    }));\n                    resolve(null);\n                }\n            });\n        },\n        [db, storeName],\n    );\n\n    // Clear all\n    const clear = useCallback(async (): Promise<boolean> => {\n        if (!db) return false;\n\n        return new Promise((resolve) => {\n            try {\n                const transaction = db.transaction(storeName, \"readwrite\");\n                const store = transaction.objectStore(storeName);\n                const request = store.clear();\n\n                request.onsuccess = () => {\n                    refresh();\n                    resolve(true);\n                };\n\n                request.onerror = () => {\n                    setState((s) => ({\n                        ...s,\n                        error:\n                            request.error?.message ?? \"Failed to clear store\",\n                    }));\n                    resolve(false);\n                };\n            } catch (error) {\n                setState((s) => ({\n                    ...s,\n                    error:\n                        error instanceof Error\n                            ? error.message\n                            : \"Failed to clear store\",\n                }));\n                resolve(false);\n            }\n        });\n    }, [db, storeName, refresh]);\n\n    return {\n        ...state,\n        add,\n        update,\n        remove,\n        getByKey,\n        clear,\n        refresh,\n    };\n}\n\nexport default useIndexedDB;\n"
    }
  ]
}