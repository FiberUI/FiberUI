{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-debounced-state",
  "type": "registry:hook",
  "title": "useDebouncedState",
  "description": "A hook for debouncing state values.",
  "categories": [
    "utility"
  ],
  "dependencies": [
    "lodash"
  ],
  "files": [
    {
      "path": "utility/use-debounced-state.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Options for the useDebouncedState hook\n */\nexport interface UseDebouncedStateOptions {\n    /** Delay in milliseconds before the value updates (default: 500) */\n    delay?: number;\n    /** If true, update immediately on the first call, then debounce subsequent calls */\n    leading?: boolean;\n}\n\n/**\n * Return type for useDebouncedState hook\n */\nexport interface UseDebouncedStateReturn<T> {\n    /** The debounced value */\n    debouncedValue: T;\n    /** Whether a debounce is pending */\n    isPending: boolean;\n    /** Cancel the pending debounce and keep current debounced value */\n    cancel: () => void;\n    /** Immediately flush the pending value */\n    flush: () => void;\n}\n\n/**\n * A React hook that debounces a value. The debounced value will only update\n * after the specified delay has passed without the value changing.\n *\n * @param value - The value to debounce\n * @param options - Configuration options\n * @returns UseDebouncedStateReturn object with debounced value and control functions\n *\n * @example\n * ```tsx\n * const [searchTerm, setSearchTerm] = useState(\"\");\n * const { debouncedValue, isPending } = useDebouncedState(searchTerm, { delay: 300 });\n *\n * useEffect(() => {\n *     // This runs only after user stops typing for 300ms\n *     fetchSearchResults(debouncedValue);\n * }, [debouncedValue]);\n * ```\n */\nexport function useDebouncedState<T>(\n    value: T,\n    options: UseDebouncedStateOptions = {},\n): UseDebouncedStateReturn<T> {\n    const { delay = 500, leading = false } = options;\n\n    const [debouncedValue, setDebouncedValue] = useState<T>(value);\n    const [isPending, setIsPending] = useState(false);\n    const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const isFirstRender = useRef(true);\n    const latestValue = useRef<T>(value);\n\n    // Keep track of the latest value for flush\n    latestValue.current = value;\n\n    // Cancel any pending timeout\n    const cancel = useCallback(() => {\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n        }\n        setIsPending(false);\n    }, []);\n\n    // Immediately update to the latest value\n    const flush = useCallback(() => {\n        cancel();\n        setDebouncedValue(latestValue.current);\n    }, [cancel]);\n\n    useEffect(() => {\n        // Handle leading edge\n        if (leading && isFirstRender.current) {\n            isFirstRender.current = false;\n            setDebouncedValue(value);\n            return;\n        }\n\n        isFirstRender.current = false;\n\n        // Skip if value hasn't changed\n        if (value === debouncedValue && !isPending) {\n            return;\n        }\n\n        setIsPending(true);\n\n        // Clear previous timeout\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n        }\n\n        // Set new timeout\n        timeoutRef.current = setTimeout(() => {\n            setDebouncedValue(value);\n            setIsPending(false);\n            timeoutRef.current = null;\n        }, delay);\n\n        // Cleanup on unmount or when dependencies change\n        return () => {\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n        };\n    }, [value, delay, leading]);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n        };\n    }, []);\n\n    return {\n        debouncedValue,\n        isPending,\n        cancel,\n        flush,\n    };\n}\n\nexport default useDebouncedState;\n"
    }
  ]
}