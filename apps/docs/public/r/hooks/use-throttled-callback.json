{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-throttled-callback",
  "type": "registry:hook",
  "title": "useThrottledCallback",
  "description": "A hook for throttling callback functions.",
  "categories": [
    "utility"
  ],
  "files": [
    {
      "path": "utility/use-throttled-callback.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Options for the useThrottledCallback hook\n */\nexport interface UseThrottledCallbackOptions {\n    /** Interval in milliseconds between executions (default: 500) */\n    interval?: number;\n    /** If true, also execute on the trailing edge after throttle period ends */\n    trailing?: boolean;\n}\n\n/**\n * Return type for useThrottledCallback hook\n */\nexport interface UseThrottledCallbackReturn<T extends (...args: any[]) => any> {\n    /** The throttled function */\n    throttledFn: (...args: Parameters<T>) => void;\n    /** Whether currently in a throttle period */\n    isThrottling: boolean;\n    /** Cancel any pending trailing call */\n    cancel: () => void;\n}\n\n/**\n * A React hook that returns a throttled version of a callback function.\n * The callback will execute at most once per interval, regardless of\n * how many times it's called.\n *\n * @param callback - The function to throttle\n * @param options - Configuration options\n * @returns UseThrottledCallbackReturn object with throttled function\n *\n * @example\n * ```tsx\n * const { throttledFn: handleScroll } = useThrottledCallback(\n *     (e: Event) => {\n *         console.log(\"Scroll position:\", window.scrollY);\n *     },\n *     { interval: 100 }\n * );\n *\n * useEffect(() => {\n *     window.addEventListener(\"scroll\", handleScroll);\n *     return () => window.removeEventListener(\"scroll\", handleScroll);\n * }, [handleScroll]);\n * ```\n */\nexport function useThrottledCallback<T extends (...args: any[]) => any>(\n    callback: T,\n    options: UseThrottledCallbackOptions = {},\n): UseThrottledCallbackReturn<T> {\n    const { interval = 500, trailing = true } = options;\n\n    const [isThrottling, setIsThrottling] = useState(false);\n    const lastExecuted = useRef<number>(0);\n    const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const callbackRef = useRef<T>(callback);\n    const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n    // Keep callback ref updated\n    callbackRef.current = callback;\n\n    // Cancel any pending trailing call\n    const cancel = useCallback(() => {\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n        }\n        setIsThrottling(false);\n        lastArgsRef.current = null;\n    }, []);\n\n    // The throttled function\n    const throttledFn = useCallback(\n        (...args: Parameters<T>) => {\n            const now = Date.now();\n            const timeSinceLastExecution = now - lastExecuted.current;\n\n            lastArgsRef.current = args;\n\n            // If enough time has passed, execute immediately\n            if (timeSinceLastExecution >= interval) {\n                callbackRef.current(...args);\n                lastExecuted.current = now;\n                setIsThrottling(false);\n\n                // Clear any pending trailing call\n                if (timeoutRef.current) {\n                    clearTimeout(timeoutRef.current);\n                    timeoutRef.current = null;\n                }\n            } else {\n                // We're in a throttle period\n                setIsThrottling(true);\n\n                // Schedule trailing call if enabled and not already scheduled\n                if (trailing && !timeoutRef.current) {\n                    const timeRemaining = interval - timeSinceLastExecution;\n                    timeoutRef.current = setTimeout(() => {\n                        if (lastArgsRef.current) {\n                            callbackRef.current(...lastArgsRef.current);\n                            lastExecuted.current = Date.now();\n                        }\n                        setIsThrottling(false);\n                        timeoutRef.current = null;\n                        lastArgsRef.current = null;\n                    }, timeRemaining);\n                }\n            }\n        },\n        [interval, trailing],\n    );\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n        };\n    }, []);\n\n    return {\n        throttledFn,\n        isThrottling,\n        cancel,\n    };\n}\n\nexport default useThrottledCallback;\n"
    }
  ]
}