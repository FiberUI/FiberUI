{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-countdown",
  "type": "registry:hook",
  "title": "useCountdown",
  "description": "A hook for creating flexible countdown timers.",
  "categories": [
    "utility"
  ],
  "files": [
    {
      "path": "utility/use-countdown.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useRef, useCallback } from \"react\";\n\n/**\n * Options for the useCountdown hook\n */\nexport interface UseCountdownOptions {\n    /** Interval in milliseconds (default: 1000) */\n    intervalMs?: number;\n    /** Whether to increment instead of decrement (default: false) */\n    isIncrement?: boolean;\n    /** Value to stop at (default: 0) */\n    countStop?: number;\n    /** Callback when countdown completes */\n    onComplete?: () => void;\n}\n\n/**\n * Return type for the useCountdown hook\n */\nexport interface UseCountdownReturn {\n    /** Current count value */\n    count: number;\n    /** Start the countdown (optionally override duration) */\n    start: (seconds?: number) => void;\n    /** Stop/Pause the countdown */\n    stop: () => void;\n    /** Reset the countdown to initial value */\n    reset: () => void;\n    /** Whether the countdown is currently active */\n    isRunning: boolean;\n}\n\n/**\n * A React hook for managing countdowns and timers.\n *\n * @param countStart - Starting count value (in seconds/units)\n * @param options - Configuration options for the countdown\n * @returns UseCountdownReturn object with count and control methods\n */\nexport function useCountdown(\n    countStart: number,\n    options: UseCountdownOptions = {},\n): UseCountdownReturn {\n    const {\n        intervalMs = 1000,\n        isIncrement = false,\n        countStop = 0,\n        onComplete,\n    } = options;\n    const [count, setCount] = useState(countStart);\n    const [isRunning, setIsRunning] = useState(false);\n    const callbackRef = useRef(onComplete);\n    const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n    // Keep callback ref updated\n    useEffect(() => {\n        callbackRef.current = onComplete;\n    }, [onComplete]);\n\n    const stop = useCallback(() => {\n        if (timerRef.current) {\n            clearInterval(timerRef.current);\n            timerRef.current = null;\n        }\n        setIsRunning(false);\n    }, []);\n\n    const start = useCallback(\n        (seconds?: number) => {\n            if (isRunning) return;\n\n            if (seconds !== undefined) {\n                setCount(seconds);\n            }\n\n            setIsRunning(true);\n            timerRef.current = setInterval(() => {\n                setCount((prevCount) => {\n                    const nextCount = isIncrement\n                        ? prevCount + 1\n                        : prevCount - 1;\n\n                    if (\n                        isIncrement\n                            ? nextCount >= countStop\n                            : nextCount <= countStop\n                    ) {\n                        stop();\n                        callbackRef.current?.();\n                        return countStop;\n                    }\n\n                    return nextCount;\n                });\n            }, intervalMs);\n        },\n        [countStop, intervalMs, isIncrement, isRunning, stop],\n    );\n\n    const reset = useCallback(() => {\n        stop();\n        setCount(countStart);\n    }, [countStart, stop]);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => stop();\n    }, [stop]);\n\n    return {\n        count,\n        start,\n        stop,\n        reset,\n        isRunning,\n    };\n}\n"
    }
  ]
}