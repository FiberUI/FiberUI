{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-picture-in-picture",
  "type": "registry:hook",
  "title": "usePictureInPicture",
  "description": "A utility hook for managing Picture-in-Picture mode for video.",
  "categories": [
    "utility"
  ],
  "files": [
    {
      "path": "utility/use-picture-in-picture.ts",
      "type": "registry:hook",
      "content": "import { useState, useCallback, useEffect } from \"react\";\n\n/**\n * Return type for the usePictureInPicture hook\n */\nexport interface UsePictureInPictureReturn {\n    /** Whether Picture-in-Picture is currently active */\n    isActive: boolean;\n    /** Whether Picture-in-Picture is supported by the browser */\n    isSupported: boolean;\n    /** Whether the PiP window is currently active */\n    window: PictureInPictureWindow | null;\n    /** Enter Picture-in-Picture mode for a video element */\n    enter: (element: HTMLVideoElement) => Promise<void>;\n    /** Exit Picture-in-Picture mode */\n    exit: () => Promise<void>;\n    /** Toggle Picture-in-Picture mode */\n    toggle: (element: HTMLVideoElement) => Promise<void>;\n}\n\n/**\n * A React hook for managing Picture-in-Picture mode for video elements.\n *\n * @returns UsePictureInPictureReturn object with state and control methods\n */\nexport function usePictureInPicture(): UsePictureInPictureReturn {\n    const [isActive, setIsActive] = useState(false);\n    const [pipWindow, setPipWindow] = useState<PictureInPictureWindow | null>(\n        null,\n    );\n\n    // Check support\n    const isSupported =\n        typeof document !== \"undefined\" &&\n        \"pictureInPictureEnabled\" in document;\n\n    // Handle enter PiP\n    const enter = useCallback(\n        async (element: HTMLVideoElement) => {\n            if (!isSupported || !element) return;\n\n            try {\n                if (element.requestPictureInPicture) {\n                    const window = await element.requestPictureInPicture();\n                    setPipWindow(window);\n                    setIsActive(true);\n                }\n            } catch (err) {\n                console.error(\"Failed to enter Picture-in-Picture:\", err);\n            }\n        },\n        [isSupported],\n    );\n\n    // Handle exit PiP\n    const exit = useCallback(async () => {\n        if (!isSupported || !document.pictureInPictureElement) return;\n\n        try {\n            await document.exitPictureInPicture();\n            setPipWindow(null);\n            setIsActive(false);\n        } catch (err) {\n            console.error(\"Failed to exit Picture-in-Picture:\", err);\n        }\n    }, [isSupported]);\n\n    // Toggle PiP\n    const toggle = useCallback(\n        async (element: HTMLVideoElement) => {\n            if (isActive) {\n                await exit();\n            } else {\n                await enter(element);\n            }\n        },\n        [isActive, enter, exit],\n    );\n\n    // Listen for PiP events\n    useEffect(() => {\n        if (!isSupported) return;\n\n        const onEnter = (e: Event) => {\n            const target = e.target as HTMLVideoElement;\n            // We can't easily get the pipWindow here without the promise return,\n            // but we know it's active.\n            setIsActive(true);\n        };\n\n        const onExit = () => {\n            setIsActive(false);\n            setPipWindow(null);\n        };\n\n        // Note: These events fire on the video element, not document.\n        // But since we don't hold the ref to the element in the hook state (to avoid re-renders or complexity),\n        // we rely on the manual enter/exit calls for primary state logic.\n        // However, external toggles (like browser UI) need to be caught.\n        // To do this properly globally is hard without the ref properly passed.\n        // A common pattern is to just listen to document for 'enterpictureinpicture' but that event is on the element.\n        // Better approach: User passes ref? Or we return a ref?\n        // Or we just rely on the user to use the toggle controls provided.\n        // For robustness, let's keep it simple: controls drive the state.\n        // But if the user closes the PiP window via the \"X\" button, we need to know.\n\n        // We can listen to 'leavepictureinpicture' on the document (capturing phase) to detect exit?\n        // Actually, 'leavepictureinpicture' bubbles? MDN says \"The event bubbles\".\n        const handleLeave = () => {\n            if (!document.pictureInPictureElement) {\n                setIsActive(false);\n                setPipWindow(null);\n            }\n        };\n\n        const handleEnter = () => {\n            if (document.pictureInPictureElement) {\n                setIsActive(true);\n            }\n        };\n\n        document.addEventListener(\"leavepictureinpicture\", handleLeave, true);\n        document.addEventListener(\"enterpictureinpicture\", handleEnter, true);\n\n        return () => {\n            document.removeEventListener(\n                \"leavepictureinpicture\",\n                handleLeave,\n                true,\n            );\n            document.removeEventListener(\n                \"enterpictureinpicture\",\n                handleEnter,\n                true,\n            );\n        };\n    }, [isSupported]);\n\n    return {\n        isActive,\n        isSupported,\n        window: pipWindow,\n        enter,\n        exit,\n        toggle,\n    };\n}\n\nexport default usePictureInPicture;\n"
    }
  ]
}