{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-event-listener",
  "type": "registry:hook",
  "title": "useEventListener",
  "description": "A type-safe hook for attaching event listeners to window, document, or any HTML element.",
  "categories": [
    "dom"
  ],
  "files": [
    {
      "path": "dom/use-event-listener.ts",
      "type": "registry:hook",
      "content": "import { RefObject, useEffect, useRef } from \"react\";\n\n/**\n * A hook to attach an event listener to the Window object.\n *\n * @param eventName - The name of the event to listen for.\n * @param handler - The function to call when the event fires.\n * @param element - The element to attach the listener to. Defaults to window.\n * @param options - Options for the event listener (passive, capture, once).\n */\nexport function useEventListener<K extends keyof WindowEventMap>(\n    eventName: K,\n    handler: (event: WindowEventMap[K]) => void,\n    element?: undefined,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\n/**\n * A hook to attach an event listener to an HTMLElement.\n *\n * @param eventName - The name of the event to listen for.\n * @param handler - The function to call when the event fires.\n * @param element - The ref object containing the target element.\n * @param options - Options for the event listener (passive, capture, once).\n */\nexport function useEventListener<\n    K extends keyof HTMLElementEventMap,\n    T extends HTMLElement = HTMLDivElement,\n>(\n    eventName: K,\n    handler: (event: HTMLElementEventMap[K]) => void,\n    element: RefObject<T | null>,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\n/**\n * A hook to attach an event listener to the Document object.\n *\n * @param eventName - The name of the event to listen for.\n * @param handler - The function to call when the event fires.\n * @param element - The target document object.\n * @param options - Options for the event listener (passive, capture, once).\n */\nexport function useEventListener<K extends keyof DocumentEventMap>(\n    eventName: K,\n    handler: (event: DocumentEventMap[K]) => void,\n    element: Document,\n    options?: boolean | AddEventListenerOptions,\n): void;\n\nexport function useEventListener<\n    KW extends keyof WindowEventMap,\n    KH extends keyof HTMLElementEventMap,\n    T extends HTMLElement | void = void,\n>(\n    eventName: KW | KH | string,\n    handler: (\n        event:\n            | WindowEventMap[KW]\n            | HTMLElementEventMap[KH]\n            | DocumentEventMap[keyof DocumentEventMap]\n            | Event,\n    ) => void,\n    element?: RefObject<T> | Document | Window,\n    options?: boolean | AddEventListenerOptions,\n) {\n    // 1. Create a ref that stores handler\n    const savedHandler = useRef(handler);\n\n    // 2. Update the saved handler if it changes, to avoid re-running the effect\n    useEffect(() => {\n        savedHandler.current = handler;\n    }, [handler]);\n\n    useEffect(() => {\n        // 3. Define the listening target\n        const targetElement: T | Window | Document | null =\n            element && \"current\" in element\n                ? element.current\n                : (element ?? window);\n\n        if (!(targetElement && targetElement.addEventListener)) {\n            return;\n        }\n\n        // 4. Create event listener that calls handler function stored in ref\n        const eventListener: typeof handler = (event) => {\n            savedHandler.current(event);\n        };\n\n        targetElement.addEventListener(eventName, eventListener, options);\n\n        // 5. Remove event listener on cleanup\n        return () => {\n            targetElement.removeEventListener(\n                eventName,\n                eventListener,\n                options,\n            );\n        };\n    }, [eventName, element, options]);\n}\n"
    }
  ]
}