{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-track-toggle",
  "type": "registry:hook",
  "title": "useTrackToggle",
  "description": "A media control hook for muting and unmuting tracks.",
  "categories": [
    "webrtc"
  ],
  "files": [
    {
      "path": "webrtc/use-track-toggle.ts",
      "type": "registry:hook",
      "content": "import { useState, useCallback, useEffect } from \"react\";\n\n/**\n * Options for the useTrackToggle hook\n */\nexport interface UseTrackToggleOptions {\n    /**\n     * Mode for toggling tracks:\n     * - 'mute': Sets track.enabled (default, keeps hardware on, allows instant toggle)\n     * - 'stop': Stops track entirely (turns hardware off, requires restart via callback)\n     */\n    mode?: \"mute\" | \"stop\";\n    /** Callback to restart video when mode is 'stop' (must return Promise) */\n    onRestartVideo?: () => Promise<boolean>;\n    /** Callback to restart audio when mode is 'stop' */\n    onRestartAudio?: () => Promise<boolean>;\n    /** Callback when video is stopped in 'stop' mode */\n    onStopVideo?: () => void;\n    /** Callback when audio is stopped in 'stop' mode */\n    onStopAudio?: () => void;\n}\n\n/**\n * Return type for the useTrackToggle hook\n */\nexport interface UseTrackToggleReturn {\n    /** Whether audio is currently enabled */\n    isAudioEnabled: boolean;\n    /** Whether video is currently enabled */\n    isVideoEnabled: boolean;\n    /** Toggle audio on/off */\n    toggleAudio: () => void;\n    /** Toggle video on/off */\n    toggleVideo: () => void;\n    /** Set audio enabled state directly */\n    setAudioEnabled: (enabled: boolean) => void;\n    /** Set video enabled state directly */\n    setVideoEnabled: (enabled: boolean) => void;\n    /** Mute all tracks (audio and video) */\n    muteAll: () => void;\n    /** Unmute all tracks (audio and video) */\n    unmuteAll: () => void;\n}\n\n/**\n * A React hook for controlling the enabled state of audio/video tracks.\n * Provides mute/unmute functionality for media streams.\n *\n * @param stream - The MediaStream to control\n * @returns UseTrackToggleReturn object with toggle states and methods\n *\n * @example\n * ```tsx\n * const { stream } = useUserMedia();\n * const { isAudioEnabled, toggleAudio, toggleVideo } = useTrackToggle(stream);\n *\n * return (\n *     <>\n *         <button onClick={toggleAudio}>\n *             {isAudioEnabled ? \"Mute\" : \"Unmute\"}\n *         </button>\n *         <button onClick={toggleVideo}>\n *             {isVideoEnabled ? \"Hide\" : \"Show\"}\n *         </button>\n *     </>\n * );\n * ```\n */\nexport function useTrackToggle(\n    stream: MediaStream | null,\n    options: UseTrackToggleOptions = {},\n): UseTrackToggleReturn {\n    const {\n        mode = \"mute\",\n        onRestartVideo,\n        onRestartAudio,\n        onStopVideo,\n        onStopAudio,\n    } = options;\n\n    const [isAudioEnabled, setIsAudioEnabled] = useState(true);\n    const [isVideoEnabled, setIsVideoEnabled] = useState(true);\n    const [isTogglingVideo, setIsTogglingVideo] = useState(false);\n    const [isTogglingAudio, setIsTogglingAudio] = useState(false);\n\n    // Sync with actual track states when stream changes\n    useEffect(() => {\n        if (!stream) {\n            setIsAudioEnabled(true);\n            setIsVideoEnabled(true);\n            return;\n        }\n\n        const audioTrack = stream.getAudioTracks()[0];\n        const videoTrack = stream.getVideoTracks()[0];\n\n        if (audioTrack) {\n            setIsAudioEnabled(audioTrack.enabled);\n        } else {\n            // No audio track means it's paused/stopped\n            setIsAudioEnabled(false);\n        }\n        if (videoTrack) {\n            setIsVideoEnabled(videoTrack.enabled);\n        } else {\n            // No video track means it's paused/stopped\n            setIsVideoEnabled(false);\n        }\n    }, [stream]);\n\n    // Set audio enabled state\n    const setAudioEnabled = useCallback(\n        async (enabled: boolean) => {\n            if (!stream) return;\n\n            if (mode === \"stop\") {\n                // Stop mode: actually stop/restart tracks\n                if (!enabled) {\n                    const audioTracks = stream.getAudioTracks();\n                    audioTracks.forEach((track) => {\n                        track.stop();\n                    });\n                    onStopAudio?.();\n                    setIsAudioEnabled(false);\n                } else if (onRestartAudio) {\n                    setIsTogglingAudio(true);\n                    const success = await onRestartAudio();\n                    setIsAudioEnabled(success);\n                    setIsTogglingAudio(false);\n                }\n            } else {\n                // Mute mode: just toggle enabled property\n                const audioTracks = stream.getAudioTracks();\n                audioTracks.forEach((track) => {\n                    track.enabled = enabled;\n                });\n                setIsAudioEnabled(enabled);\n            }\n        },\n        [stream, mode, onRestartAudio, onStopAudio],\n    );\n\n    // Set video enabled state\n    const setVideoEnabled = useCallback(\n        async (enabled: boolean) => {\n            if (!stream) return;\n\n            if (mode === \"stop\") {\n                // Stop mode: actually stop/restart tracks\n                if (!enabled) {\n                    const videoTracks = stream.getVideoTracks();\n                    videoTracks.forEach((track) => {\n                        track.stop();\n                    });\n                    onStopVideo?.();\n                    setIsVideoEnabled(false);\n                } else if (onRestartVideo) {\n                    setIsTogglingVideo(true);\n                    const success = await onRestartVideo();\n                    setIsVideoEnabled(success);\n                    setIsTogglingVideo(false);\n                }\n            } else {\n                // Mute mode: just toggle enabled property\n                const videoTracks = stream.getVideoTracks();\n                videoTracks.forEach((track) => {\n                    track.enabled = enabled;\n                });\n                setIsVideoEnabled(enabled);\n            }\n        },\n        [stream, mode, onRestartVideo, onStopVideo],\n    );\n\n    // Toggle audio\n    const toggleAudio = useCallback(() => {\n        if (isTogglingAudio) return; // Prevent double-toggle during async restart\n        setAudioEnabled(!isAudioEnabled);\n    }, [isAudioEnabled, setAudioEnabled, isTogglingAudio]);\n\n    // Toggle video\n    const toggleVideo = useCallback(() => {\n        if (isTogglingVideo) return; // Prevent double-toggle during async restart\n        setVideoEnabled(!isVideoEnabled);\n    }, [isVideoEnabled, setVideoEnabled, isTogglingVideo]);\n\n    // Mute all tracks\n    const muteAll = useCallback(() => {\n        setAudioEnabled(false);\n        setVideoEnabled(false);\n    }, [setAudioEnabled, setVideoEnabled]);\n\n    // Unmute all tracks\n    const unmuteAll = useCallback(() => {\n        setAudioEnabled(true);\n        setVideoEnabled(true);\n    }, [setAudioEnabled, setVideoEnabled]);\n\n    return {\n        isAudioEnabled,\n        isVideoEnabled,\n        toggleAudio,\n        toggleVideo,\n        setAudioEnabled,\n        setVideoEnabled,\n        muteAll,\n        unmuteAll,\n    };\n}\n\nexport default useTrackToggle;\n"
    }
  ]
}