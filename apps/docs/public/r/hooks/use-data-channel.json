{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-data-channel",
  "type": "registry:hook",
  "title": "useDataChannel",
  "description": "A React hook for managing WebRTC Data Channels.",
  "categories": [
    "webrtc"
  ],
  "files": [
    {
      "path": "webrtc/use-data-channel.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Options for the useDataChannel hook\n */\nexport interface UseDataChannelOptions {\n    /** Label for the data channel */\n    label: string;\n    /** RTCDataChannel configuration options */\n    channelOptions?: RTCDataChannelInit;\n    /** Whether to create the channel immediately (default: true for offerer) */\n    autoCreate?: boolean;\n    /** Callback when a message is received */\n    onMessage?: (data: string | ArrayBuffer) => void;\n    /** Callback when channel opens */\n    onOpen?: () => void;\n    /** Callback when channel closes */\n    onClose?: () => void;\n    /** Callback when error occurs */\n    onError?: (error: Event) => void;\n}\n\n/**\n * Message with metadata\n */\nexport interface DataChannelMessage {\n    /** Message data (string or binary) */\n    data: string | ArrayBuffer;\n    /** Timestamp when received */\n    timestamp: number;\n    /** Whether this is a binary message */\n    isBinary: boolean;\n}\n\n/**\n * Return type for the useDataChannel hook\n */\nexport interface UseDataChannelReturn {\n    /** The RTCDataChannel instance */\n    channel: RTCDataChannel | null;\n    /** Current ready state of the channel */\n    readyState: RTCDataChannelState;\n    /** Whether the channel is open and ready to send */\n    isOpen: boolean;\n    /** Send a string message */\n    send: (data: string) => boolean;\n    /** Send binary data */\n    sendBinary: (data: ArrayBuffer | Blob) => boolean;\n    /** Send JSON data */\n    sendJSON: <T>(data: T) => boolean;\n    /** Received messages history */\n    messages: DataChannelMessage[];\n    /** Most recent message */\n    lastMessage: DataChannelMessage | null;\n    /** Clear message history */\n    clearMessages: () => void;\n    /** Buffered amount of data waiting to be sent */\n    bufferedAmount: number;\n}\n\n/**\n * A React hook for managing WebRTC data channels.\n * Provides P2P messaging for chat, file transfer, or game state.\n *\n * @param peerConnection - The RTCPeerConnection to use\n * @param options - Configuration options for the data channel\n * @returns UseDataChannelReturn object with channel, states, and methods\n *\n * @example\n * ```tsx\n * const { createDataChannel } = usePeerConnection();\n * const { send, messages, isOpen } = useDataChannel(peerConnection, {\n *     label: \"chat\",\n *     onMessage: (data) => console.log(\"Received:\", data),\n * });\n *\n * // Send a message\n * if (isOpen) {\n *     send(\"Hello, peer!\");\n * }\n * ```\n */\nexport function useDataChannel(\n    peerConnection: RTCPeerConnection | null,\n    options: UseDataChannelOptions,\n): UseDataChannelReturn {\n    const {\n        label,\n        channelOptions,\n        autoCreate = true,\n        onMessage,\n        onOpen,\n        onClose,\n        onError,\n    } = options;\n\n    const [channel, setChannel] = useState<RTCDataChannel | null>(null);\n    const [readyState, setReadyState] =\n        useState<RTCDataChannelState>(\"connecting\");\n    const [messages, setMessages] = useState<DataChannelMessage[]>([]);\n    const [bufferedAmount, setBufferedAmount] = useState(0);\n\n    // Store callbacks in refs\n    const onMessageRef = useRef(onMessage);\n    const onOpenRef = useRef(onOpen);\n    const onCloseRef = useRef(onClose);\n    const onErrorRef = useRef(onError);\n\n    onMessageRef.current = onMessage;\n    onOpenRef.current = onOpen;\n    onCloseRef.current = onClose;\n    onErrorRef.current = onError;\n\n    // Setup channel event handlers\n    const setupChannel = useCallback((dc: RTCDataChannel) => {\n        dc.onopen = () => {\n            setReadyState(\"open\");\n            onOpenRef.current?.();\n        };\n\n        dc.onclose = () => {\n            setReadyState(\"closed\");\n            onCloseRef.current?.();\n        };\n\n        dc.onerror = (event) => {\n            onErrorRef.current?.(event);\n        };\n\n        dc.onmessage = (event) => {\n            const message: DataChannelMessage = {\n                data: event.data,\n                timestamp: Date.now(),\n                isBinary: event.data instanceof ArrayBuffer,\n            };\n            setMessages((prev) => [...prev, message]);\n            onMessageRef.current?.(event.data);\n        };\n\n        dc.onbufferedamountlow = () => {\n            setBufferedAmount(dc.bufferedAmount);\n        };\n\n        setChannel(dc);\n        setReadyState(dc.readyState);\n    }, []);\n\n    // Create or receive data channel\n    useEffect(() => {\n        if (!peerConnection) return;\n\n        // Handle incoming data channel from remote peer\n        const handleDataChannel = (event: RTCDataChannelEvent) => {\n            if (event.channel.label === label) {\n                setupChannel(event.channel);\n            }\n        };\n\n        peerConnection.addEventListener(\"datachannel\", handleDataChannel);\n\n        // Create channel if we're the offerer\n        if (autoCreate && !channel) {\n            try {\n                const dc = peerConnection.createDataChannel(\n                    label,\n                    channelOptions,\n                );\n                setupChannel(dc);\n            } catch (err) {\n                console.error(\"Failed to create data channel:\", err);\n            }\n        }\n\n        return () => {\n            peerConnection.removeEventListener(\n                \"datachannel\",\n                handleDataChannel,\n            );\n        };\n    }, [\n        peerConnection,\n        label,\n        channelOptions,\n        autoCreate,\n        channel,\n        setupChannel,\n    ]);\n\n    // Send string message\n    const send = useCallback(\n        (data: string): boolean => {\n            if (!channel || channel.readyState !== \"open\") return false;\n\n            try {\n                channel.send(data);\n                setBufferedAmount(channel.bufferedAmount);\n                return true;\n            } catch (err) {\n                console.error(\"Failed to send message:\", err);\n                return false;\n            }\n        },\n        [channel],\n    );\n\n    // Send binary data\n    const sendBinary = useCallback(\n        (data: ArrayBuffer | Blob): boolean => {\n            if (!channel || channel.readyState !== \"open\") return false;\n\n            try {\n                if (data instanceof Blob) {\n                    // For Blob, we need to convert to ArrayBuffer\n                    data.arrayBuffer().then((buffer) => {\n                        channel.send(buffer);\n                    });\n                } else {\n                    channel.send(data);\n                }\n                setBufferedAmount(channel.bufferedAmount);\n                return true;\n            } catch (err) {\n                console.error(\"Failed to send binary data:\", err);\n                return false;\n            }\n        },\n        [channel],\n    );\n\n    // Send JSON data\n    const sendJSON = useCallback(\n        <T>(data: T): boolean => {\n            try {\n                return send(JSON.stringify(data));\n            } catch (err) {\n                console.error(\"Failed to serialize JSON:\", err);\n                return false;\n            }\n        },\n        [send],\n    );\n\n    // Clear messages\n    const clearMessages = useCallback(() => {\n        setMessages([]);\n    }, []);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (channel) {\n                channel.close();\n            }\n        };\n    }, [channel]);\n\n    return {\n        channel,\n        readyState,\n        isOpen: readyState === \"open\",\n        send,\n        sendBinary,\n        sendJSON,\n        messages,\n        lastMessage: messages[messages.length - 1] ?? null,\n        clearMessages,\n        bufferedAmount,\n    };\n}\n\nexport default useDataChannel;\n"
    }
  ]
}